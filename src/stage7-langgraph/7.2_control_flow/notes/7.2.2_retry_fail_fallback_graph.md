# âš™ï¸ **7.2.2 â€” Retry Node (Error Handling + Fallback Mechanism)**

## ğŸ¯ **Goal**

Create a LangGraph flow where:

- A node may fail
- The graph catches the failure (without crashing)
- Automatically retries **N** times
- If still failing:
  â†’ gracefully fall back to an alternate node
  â†’ OR return a safe response

This is the foundation of **production-grade AI orchestration**.

---

# âœ… **THE CONCEPT**

LangGraph gives us two core techniques:

### âœ… **Technique A â€” Built-in `retry()` wrapper**

Every node can be wrapped with:

```ts
const safeNode = retry(nodeFn, { retries: 3 })
```

### âœ… **Technique B â€” Conditional error transitions**

Graph decides next state based on error flags:

```
Node A
 â”œâ”€â”€ success â†’ nextNode
 â””â”€â”€ error â†’ fallbackNode
```

Weâ€™ll combine **both** for an â€œindustrial-grade retry patternâ€.

---

# âœ… **7.2.2 Implementation â€” â€œFail â†’ Retry â†’ Fallback Graphâ€**

This example simulates a failing API/tool/LLM node.

---

# 1ï¸âƒ£ **State Definition**

```ts
import { StateGraph, Annotation, END } from '@langchain/langgraph'
import { ChatOpenAI } from '@langchain/openai'
import { retry } from '@langchain/core/utils'
import 'dotenv/config'

const StateAnnotation = Annotation.Root({
  input: Annotation<string>(),
  output: Annotation<string>(),
  error: Annotation<string | null>({
    reducer: (_c, next) => next,
  }),
})
```

---

# 2ï¸âƒ£ **Unstable Node (Fails Randomly)**

Simulating flaky API / tool.

```ts
async function riskyNode(state: typeof StateAnnotation.State) {
  console.log('âš ï¸ Running risky nodeâ€¦')

  // Simulate random failure 50% of time
  if (Math.random() < 0.5) {
    throw new Error('Random failure occurred!')
  }

  return { output: `âœ… Success: Processed "${state.input}"`, error: null }
}
```

---

# 3ï¸âƒ£ **Wrap risky node with automatic retries**

```ts
const safeRiskyNode = retry(riskyNode, {
  retries: 3,
  delay: 300, // optional
})
```

âœ… Retry 3 times
âœ… Automatically catches errors
âœ… Waits 300ms between retries

---

# 4ï¸âƒ£ **Fallback Node**

Executed if retries fail:

```ts
async function fallbackNode(state: typeof StateAnnotation.State) {
  console.log('ğŸ›Ÿ Fallback activated.')
  return {
    output: 'âš ï¸ The system is experiencing issues. Try again later.',
    error: null,
  }
}
```

---

# 5ï¸âƒ£ **Error Handler Node**

This detects success vs failure:

```ts
async function errorCheckNode(state: typeof StateAnnotation.State) {
  return { error: state.error }
}
```

---

# 6ï¸âƒ£ **Build the Graph (Control Flow)**

```ts
const graph = new StateGraph(StateAnnotation)
  .addNode('risky', async (state) => {
    try {
      return await safeRiskyNode(state)
    } catch (e: any) {
      console.log('âŒ All retries failed')
      return { error: e.message }
    }
  })
  .addNode('fallback', fallbackNode)
  .addNode('errorCheck', errorCheckNode)
  .addEdge('__start__', 'risky')
  .addEdge('risky', 'errorCheck')
  .addConditionalEdges(
    'errorCheck',
    (state) => {
      if (!state.error) return 'success'
      return 'fallback'
    },
    {
      success: END,
      fallback: 'fallback',
    },
  )
  .addEdge('fallback', END)

const app = graph.compile()
```

---

# 7ï¸âƒ£ **Run Demo**

```ts
async function main() {
  console.log('\n=== Retry + Fallback Demo ===')
  const result = await app.invoke({ input: 'Process this task' })
  console.log('\nFINAL STATE:\n', result)
}

main()
```

---

# âœ… **Expected Output**

### Successful path:

```
âš ï¸ Running risky nodeâ€¦
âš ï¸ Running risky nodeâ€¦
âœ… Success: Processed "Process this task"
âœ… Final:
{
  input: "Process this task",
  output: "âœ… Success: Processed ...",
  error: null
}
```

### Failure â†’ Retry â†’ Fallback path:

```
âš ï¸ Running risky nodeâ€¦
âŒ failed
âš ï¸ Running risky nodeâ€¦
âŒ failed
âš ï¸ Running risky nodeâ€¦
âŒ failed
âŒ All retries failed
ğŸ›Ÿ Fallback activated.
âœ… Final:
{
  output: "âš ï¸ The system is experiencing issues. Try again later."
}
```

---

# âœ… **Key Learnings**

| Concept                   | Explanation                                                                   |
| ------------------------- | ----------------------------------------------------------------------------- |
| **Retry wrapper**         | Automatic LLM/tool retry policy                                               |
| **Conditional fallback**  | Route dynamically based on error state                                        |
| **Resilient graphs**      | Agents that don't crash on errors                                             |
| **Interactive debugging** | See each attempt through logs                                                 |
| **Production practice**   | Mirrors real-world retry systems (Airflow, Durable Functions, Step Functions) |

This is foundational for:
âœ… Unstable APIs
âœ… Scrapers
âœ… Web search
âœ… Multi-agent task planners
âœ… Tool usage

---

# âœ… **7.2.2 Complete**

You're now able to build **fault-tolerant LangGraph workflows**.
