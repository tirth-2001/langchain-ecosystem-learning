# ğŸ”¥ **7.4.5 â€” Error Tool Node (Fallback & Recovery Node)**

_A resilient agent should never crash â€” it should recover, fallback, or gracefully respond._

---

# **1) GOAL**

In this module, you will learn how to:

### ğŸ¯ **Add an Error Tool Node**

A node whose job is to:

- Catch failures from other nodes
- Log/record error details
- Decide how to recover
- Return a safe, user-friendly message

### ğŸ¯ **Implement Error Routing**

Graph routes execution to the error node if:

- LLM tool nodes throw exceptions
- Web/API tool nodes fail (network, timeout, invalid data)
- Runtime errors occur inside a node

### ğŸ¯ **Build a Final Fallback Node**

Ensures the agent always returns something meaningful even when unexpected errors happen.

---

# **2) THEORY & CONCEPTS**

## ğŸ§± What is an Error Tool Node?

A normal node in LangGraph, but wrapped in try/catch:

```ts
async function errorToolNode(state) {
  // logs error, decides next step, produces fallback
}
```

## ğŸ”€ How does error routing work?

We use this pattern:

```
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Normal Tool Node        â”‚
         â”‚ (might throw error)     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ try/catch
                if failâ”‚
                       â–¼
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚ Error Handler Node â”‚
             â”‚ - logs             â”‚
             â”‚ - fallback         â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why do we need this?

- Tools often fail â€” web APIs, invalid parameters, missing keys, etc.
- LLM output may be malformed
- You want a robust, production-safe agent that never crashes

---

# **3) CODE SNIPPETS (Step-by-step)**

## **3.1 â€” State Definition**

We track:

- input (user request)
- result (tool/LLM response)
- error (optional error message)
- toolUsed (for debugging)

```ts
const StateAnnotation = Annotation.Root({
  input: Annotation<string>(),
  result: Annotation<string | null>(),
  error: Annotation<string | null>(),
  toolUsed: Annotation<string | null>(),
})
```

---

## **3.2 â€” Normal Tool Node (may fail)**

This node intentionally throws errors in some cases to test fallback logic.

```ts
async function riskyToolNode(state: typeof StateAnnotation.State) {
  console.log('ğŸ”§ riskyToolNode running...')

  // Simulate random failure or missing data
  if (!state.input || state.input.length < 5) {
    throw new Error('Input too short for processing.')
  }

  if (Math.random() < 0.3) {
    throw new Error('Random failure occurred in riskyToolNode.')
  }

  // Simulated success
  const result = `Processed successfully: ${state.input}`
  return { result, toolUsed: 'riskyTool' }
}
```

---

## **3.3 â€” Error Tool Node (catch-all fallback)**

```ts
async function errorToolNode(state: typeof StateAnnotation.State) {
  console.log('âŒ errorToolNode invoked')

  const fallback = `
The system encountered an error while processing your request.
Error: ${state.error}
Please try again or rephrase your input.
  `.trim()

  return {
    result: fallback,
    toolUsed: 'errorHandler',
  }
}
```

---

## **3.4 â€” Wrapper Node (try/catch node)**

This is the important trick:
We wrap the risky tool node inside a safe wrapper that catches errors and routes state.

```ts
async function safeToolWrapper(state: typeof StateAnnotation.State) {
  try {
    return await riskyToolNode(state)
  } catch (err: any) {
    console.log('âš ï¸ safeToolWrapper caught error:', err.message)
    return { error: err.message } // reducer stores error in state
  }
}
```

---

## **3.5 â€” Final Response Node**

```ts
function answerNode(state: typeof StateAnnotation.State) {
  console.log('ğŸ’¬ answerNode reached')
  return { result: state.result }
}
```

---

## **3.6 â€” Routing Logic**

A conditional edge checks:

- If `state.error` exists â†’ go to `errorToolNode`
- Else â†’ go to `answerNode`

```ts
const workflow = new StateGraph(StateAnnotation)
  .addNode('safeTool', safeToolWrapper)
  .addNode('errorHandler', errorToolNode)
  .addNode('finalAnswer', answerNode)
  .addEdge(START, 'safeTool')
  .addConditionalEdges('safeTool', (state) => (state.error ? 'has_error' : 'ok'), {
    has_error: 'errorHandler',
    ok: 'finalAnswer',
  })
  .addEdge('errorHandler', 'finalAnswer')
  .addEdge('finalAnswer', END)
```

---

# **4) FINAL PLUG-N-PLAY FILE (Full Working Code)**

This is a complete runnable file.

---

### **ğŸ“Œ `error-tool-graph.ts`**

```ts
import { Annotation, StateGraph, END, START } from '@langchain/langgraph'
import 'dotenv/config'

/**
 * 1) State Definition
 */
const StateAnnotation = Annotation.Root({
  input: Annotation<string>(),
  result: Annotation<string | null>(),
  error: Annotation<string | null>(),
  toolUsed: Annotation<string | null>(),
})

/**
 * 2) Normal Tool (may throw errors)
 */
async function riskyToolNode(state: typeof StateAnnotation.State) {
  console.log('ğŸ”§ riskyToolNode running...')

  // Simulated validation failure
  if (!state.input || state.input.length < 5) {
    throw new Error('Input too short for processing.')
  }

  // Simulated random failure
  if (Math.random() < 0.4) {
    throw new Error('Random failure occurred inside riskyToolNode.')
  }

  const result = `Tool processed successfully: ${state.input}`
  return { result, toolUsed: 'riskyTool' }
}

/**
 * 3) Safe Wrapper Node
 * Wraps the tool in try/catch and stores the error in state.
 */
async function safeToolWrapper(state: typeof StateAnnotation.State) {
  try {
    return await riskyToolNode(state)
  } catch (err: any) {
    console.log('âš ï¸ safeToolWrapper caught error:', err.message)
    return { error: err.message }
  }
}

/**
 * 4) Error Handling Node
 */
async function errorToolNode(state: typeof StateAnnotation.State) {
  console.log('âŒ errorToolNode invoked')

  const fallback = `
The system encountered an error while processing your request.
Error: ${state.error}
Try rephrasing or retrying later.
  `.trim()

  return {
    result: fallback,
    toolUsed: 'errorHandler',
  }
}

/**
 * 5) Final Node
 */
async function finalAnswerNode(state: typeof StateAnnotation.State) {
  console.log('ğŸ’¬ finalAnswerNode reached')
  return { result: state.result }
}

/**
 * 6) Build Graph
 */
const workflow = new StateGraph(StateAnnotation)
  .addNode('safeTool', safeToolWrapper)
  .addNode('errorHandler', errorToolNode)
  .addNode('finalAnswer', finalAnswerNode)
  .addEdge(START, 'safeTool')
  .addConditionalEdges('safeTool', (state) => (state.error ? 'has_error' : 'ok'), {
    has_error: 'errorHandler',
    ok: 'finalAnswer',
  })
  .addEdge('errorHandler', 'finalAnswer')
  .addEdge('finalAnswer', END)

const app = workflow.compile()

/**
 * 7) Demo
 */
async function main() {
  const input = 'test' // Try "test" (short â†’ error) or "Process this text"
  const result = await app.invoke({ input })

  console.log('\nğŸš€ FINAL RESULT:')
  console.log(result)
}

main().catch(console.error)
```

---

# **5) NOTES & TIPS**

### âœ” 1. Every graph should have a fallback path

Otherwise errors kill the whole execution.

### âœ” 2. Tools should never directly throw errors

Wrap them inside a safe wrapper node.

### âœ” 3. Use RAG or LLM in error node

You can even do:

- â€œRewrite the error in friendly languageâ€
- â€œSuggest alternative queriesâ€
- â€œProvide troubleshootingâ€

### âœ” 4. Production Tip

Send errors to:

- Sentry
- Datadog
- Mongo â€œagent_logsâ€ collection
- Slack alert

### âœ” 5. Combine with HITL

If error is risky:

```
safeTool â†’ errorHandler â†’ HITL â†’ finalAnswer
```
