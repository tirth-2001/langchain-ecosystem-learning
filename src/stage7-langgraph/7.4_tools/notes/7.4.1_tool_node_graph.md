# üß© 7.4.1 ‚Äî Tool Node (Internal Function Inside Graph)

---

## 1Ô∏è‚É£ Goal

Build a **simple LangGraph workflow** where a node:

- Calls an **internal function (tool)** ‚Äì here: a **calculator function**
- Stores the result in graph state
- Optionally uses LLM to **nicely format** the final answer

Flow:

```
User Input (math expression)
  ‚Üì
[calculatorNode]  -- (pure JS/TS function)
  ‚Üì
[answerNode]      -- (LLM formats the result)
  ‚Üì
END
```

No classification, no branching yet ‚Äî just **tool-as-node**.

---

## 2Ô∏è‚É£ Theory & Concepts

### üîπ 2.1 What is a Tool Node?

In this context, a **tool node** is just:

- A **graph node** whose implementation calls some **deterministic code**:

  - calculator
  - date formatter
  - business rule engine
  - database reader

- It **does not depend on the LLM** ‚Äî it‚Äôs pure application logic.

So instead of:

> ‚ÄúLLM, please compute 12 \* 9‚Äù

we do:

> ‚ÄúGraph, call the calculator node, then give the result to the LLM for explanation.‚Äù

---

### üîπ 2.2 Tool Node Pattern in LangGraph

Typical pattern:

1. **State includes** fields for:

   - `input` ‚Üí user query / expression
   - `toolResult` ‚Üí raw result from tool
   - `answer` ‚Üí final string to show user

2. Graph nodes:

   - `calculatorNode` ‚Üí calls internal function ‚Üí returns `{ toolResult }`
   - `answerNode` ‚Üí reads `input + toolResult` ‚Üí returns `{ answer }`

3. Edges:

   ```text
   START ‚Üí calculatorNode ‚Üí answerNode ‚Üí END
   ```

---

### üîπ 2.3 Why Start Simple (No Classifier Yet)?

Because later (7.4.3) we‚Äôll handle:

> ‚ÄúDoes this query need tool or just LLM?‚Äù

In this substage, we‚Äôre just learning **how to wrap a function inside a graph node** and wire state through.

---

## 3Ô∏è‚É£ Code Snippets (Step by Step)

### ‚úÖ 3.1 State Definition

We‚Äôll model the state like this:

- `input`: string ‚Äî user expression (e.g. `"12 * (8 + 2)"`)
- `toolResult`: string ‚Äî raw calculated output
- `answer`: string ‚Äî final message to user

```ts
import { Annotation } from '@langchain/langgraph'

const StateAnnotation = Annotation.Root({
  input: Annotation<string>(),
  toolResult: Annotation<string>({
    reducer: (curr, next) => next ?? curr,
  }),
  answer: Annotation<string>({
    reducer: (curr, next) => next ?? curr,
  }),
})
```

---

### ‚úÖ 3.2 Calculator Tool (Internal Function)

For demo purposes, we‚Äôll implement a **very naive** calculator.

> ‚ö†Ô∏è **Note:** This uses `eval` with basic sanitization. In production, use a proper math parser (`mathjs`, custom parser, etc.).

```ts
function calculatorTool(expression: string): number | null {
  try {
    // Allow only digits, operators, parentheses, spaces, and dots
    const safeExpr = expression.replace(/[^0-9+\-*/().\s]/g, '')
    // eslint-disable-next-line no-eval
    const result = eval(safeExpr)
    if (typeof result === 'number' && Number.isFinite(result)) {
      return result
    }
    return null
  } catch {
    return null
  }
}
```

---

### ‚úÖ 3.3 Tool Node: `calculatorNode`

This node reads `state.input`, calls the tool, and writes `toolResult`.

```ts
async function calculatorNode(state: typeof StateAnnotation.State) {
  console.log('üßÆ calculatorNode: evaluating expression:', state.input)

  const result = calculatorTool(state.input)
  if (result === null) {
    return { toolResult: 'Error: could not compute expression.' }
  }

  return { toolResult: result.toString() }
}
```

---

### ‚úÖ 3.4 LLM Answer Node: `answerNode`

This node:

- Reads `input` + `toolResult`
- Asks the LLM to generate a helpful final answer

```ts
import { ChatOpenAI } from '@langchain/openai'
import { ChatPromptTemplate } from '@langchain/core/prompts'
import { RunnableSequence } from '@langchain/core/runnables'

const model = new ChatOpenAI({
  modelName: 'gpt-4o-mini',
  temperature: 0,
})

const answerPrompt = ChatPromptTemplate.fromTemplate(`
You are a helpful assistant.

The user asked:
{input}

A calculator tool produced this result:
{toolResult}

Explain the result briefly to the user in a clear, friendly way.
`)

const answerChain = RunnableSequence.from([answerPrompt, model, (out) => out.content.trim()])

async function answerNode(state: typeof StateAnnotation.State) {
  console.log('üí¨ answerNode: formatting final response...')

  const answer = await answerChain.invoke({
    input: state.input,
    toolResult: state.toolResult,
  })

  return { answer }
}
```

---

### ‚úÖ 3.5 Graph Wiring

```ts
import { StateGraph, START, END } from '@langchain/langgraph'

const workflow = new StateGraph(StateAnnotation)
  .addNode('calculatorNode', calculatorNode)
  .addNode('answerNode', answerNode)
  .addEdge(START, 'calculatorNode')
  .addEdge('calculatorNode', 'answerNode')
  .addEdge('answerNode', END)

const app = workflow.compile()
```

---

### ‚úÖ 3.6 Demo Runner

```ts
async function main() {
  console.log('\n=== 7.4.1 ‚Äî Tool Node (Calculator) Demo ===\n')

  const queries = ['12 * (8 + 2)', '100 / 4 + 7 * 3', '2.5 * 3.6']

  for (const input of queries) {
    console.log(`\nüë§ User: ${input}`)
    const result = await app.invoke({ input })
    console.log('üßÆ Tool Result:', result.toolResult)
    console.log('ü§ñ Final Answer:', result.answer)
  }
}

main().catch(console.error)
```

---

## 4Ô∏è‚É£ Final File ‚Äî Plug-and-Play

> üìÑ `graph-tool-node.ts`
> (Single TS file you can run with `ts-node graph-tool-node.ts`)

```ts
import { Annotation, StateGraph, START, END } from '@langchain/langgraph'
import { ChatOpenAI } from '@langchain/openai'
import { ChatPromptTemplate } from '@langchain/core/prompts'
import { RunnableSequence } from '@langchain/core/runnables'
import 'dotenv/config'

/**
 * 1Ô∏è‚É£ State Model
 */
const StateAnnotation = Annotation.Root({
  input: Annotation<string>(),
  toolResult: Annotation<string>({
    reducer: (curr, next) => next ?? curr,
  }),
  answer: Annotation<string>({
    reducer: (curr, next) => next ?? curr,
  }),
})

/**
 * 2Ô∏è‚É£ Internal Calculator Tool (Demo Only)
 */
function calculatorTool(expression: string): number | null {
  try {
    // Very naive sanitizer: allow digits, operators, parentheses, spaces, and dots
    const safeExpr = expression.replace(/[^0-9+\-*/().\s]/g, '')
    // ‚ö†Ô∏è Do NOT use eval in production. Use a math parser instead.
    // eslint-disable-next-line no-eval
    const result = eval(safeExpr)
    if (typeof result === 'number' && Number.isFinite(result)) {
      return result
    }
    return null
  } catch {
    return null
  }
}

/**
 * 3Ô∏è‚É£ Nodes
 */

// Tool Node: calls calculatorTool
async function calculatorNode(state: typeof StateAnnotation.State) {
  console.log('üßÆ calculatorNode: evaluating expression:', state.input)

  const result = calculatorTool(state.input)
  if (result === null) {
    return { toolResult: 'Error: could not compute expression.' }
  }

  return { toolResult: result.toString() }
}

// LLM Answer Node
const model = new ChatOpenAI({
  modelName: 'gpt-4o-mini',
  temperature: 0,
})

const answerPrompt = ChatPromptTemplate.fromTemplate(`
You are a helpful assistant.

The user asked:
{input}

A calculator tool produced this result:
{toolResult}

Explain the result briefly to the user in a clear, friendly way.
`)

const answerChain = RunnableSequence.from([answerPrompt, model, (out) => out.content.trim()])

async function answerNode(state: typeof StateAnnotation.State) {
  console.log('üí¨ answerNode: formatting final response...')

  const answer = await answerChain.invoke({
    input: state.input,
    toolResult: state.toolResult,
  })

  return { answer }
}

/**
 * 4Ô∏è‚É£ Graph Definition
 */
const workflow = new StateGraph(StateAnnotation)
  .addNode('calculatorNode', calculatorNode)
  .addNode('answerNode', answerNode)
  .addEdge(START, 'calculatorNode')
  .addEdge('calculatorNode', 'answerNode')
  .addEdge('answerNode', END)

const app = workflow.compile()

/**
 * 5Ô∏è‚É£ Demo Runner
 */
async function main() {
  console.log('\n=== 7.4.1 ‚Äî Tool Node (Calculator) Demo ===\n')

  const queries = [
    '12 * (8 + 2)',
    '100 / 4 + 7 * 3',
    '2.5 * 3.6',
    'hello world', // invalid
  ]

  for (const input of queries) {
    console.log(`\nüë§ User: ${input}`)
    const result = await app.invoke({ input })
    console.log('üßÆ Tool Result:', result.toolResult)
    console.log('ü§ñ Final Answer:', result.answer)
  }
}

main().catch(console.error)
```

---

## 5Ô∏è‚É£ Notes & Tips

- **Core takeaway**:
  A ‚Äútool‚Äù is just **a function** wrapped in a graph node that reads from state and writes to state.

- **Why this is powerful**:

  - You can plug _any_ internal service: pricing engine, DB query, feature flag, etc.
  - The LLM becomes just one node among many.

- **Production tip**:

  - Replace `eval` with a real math parser.
  - Add validation & error-safe fallbacks in `calculatorTool`.
