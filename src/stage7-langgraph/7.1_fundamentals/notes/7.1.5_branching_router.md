# âš™ï¸ **7.1.5 â€” Branching / Router Logic (Conditional Routes)**

---

## ğŸ¯ **Goal**

Weâ€™ll make a LangGraph that:

- Uses an **LLM classifier node** to decide the route,
- Then follows **different downstream nodes** depending on the decision.

Example workflow:

```
User Input
  â†“
[ Classifier Node ]
  â”œâ”€â”€â†’ [ Answer Node ]  (if general query)
  â””â”€â”€â†’ [ Tool Node ]    (if calculation query)
```

This introduces **conditional edges** (`.addConditionalEdges()`) â€”
which allow graphs to choose different next steps dynamically at runtime.

---

## ğŸ§  **Conceptual Overview**

| Node         | Purpose                                              |
| ------------ | ---------------------------------------------------- |
| `router`     | Uses LLM to decide intent (e.g. â€œmathâ€ or â€œgeneralâ€) |
| `answerer`   | Handles general text answers                         |
| `calculator` | Handles numeric/calculation tasks                    |

### Example Intents

| Input                     | Route          |
| ------------------------- | -------------- |
| â€œWho is Albert Einstein?â€ | â†’ `answerer`   |
| â€œWhat is 42 Ã— 8?â€         | â†’ `calculator` |

---

## ğŸ§© **Visual Flow**

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ User Input     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
        [ Router Node ]
         â”œâ”€â”€ "general" â†’ [ LLM Answer Node ]
         â””â”€â”€ "math"    â†’ [ Calculator Node ]
                â†“
               END
```

---

## ğŸ’» **Implementation**

### ğŸ“ `src/langgraph/7.1.5-router-graph.ts`

```ts
import { StateGraph, Annotation, END } from '@langchain/langgraph'
import { ChatOpenAI } from '@langchain/openai'
import { ChatPromptTemplate } from '@langchain/core/prompts'
import { RunnableSequence } from '@langchain/core/runnables'
import dotenv from 'dotenv'
dotenv.config()

/**
 * 1ï¸âƒ£ Define State
 */
const StateAnnotation = Annotation.Root({
  query: Annotation<string>({ reducer: (curr, next) => next }),
  route: Annotation<string>({ reducer: (curr, next) => next }),
  result: Annotation<string>({ reducer: (curr, next) => next }),
})

/**
 * 2ï¸âƒ£ Router Node
 * Classifies input type: "general" or "math"
 */
const routerPrompt = ChatPromptTemplate.fromTemplate(`
Classify the user's question into one of two categories: "general" or "math".
Respond with only one word: general OR math.

Question: {query}
`)

const routerModel = new ChatOpenAI({ modelName: 'gpt-4o-mini', temperature: 0 })
const routerChain = RunnableSequence.from([routerPrompt, routerModel, (out) => out.content.trim().toLowerCase()])

async function routerNode(state: typeof StateAnnotation.State) {
  const route = await routerChain.invoke({ query: state.query })
  console.log('ğŸ§­ Routing to:', route)
  return { route }
}

/**
 * 3ï¸âƒ£ Answer Node (general)
 */
const answerPrompt = ChatPromptTemplate.fromTemplate(`Answer briefly and clearly:\n\n{query}`)
const answerModel = new ChatOpenAI({ modelName: 'gpt-4o-mini', temperature: 0.5 })
const answerChain = RunnableSequence.from([answerPrompt, answerModel, (out) => ({ result: out.content })])

async function answerNode(state: typeof StateAnnotation.State) {
  return await answerChain.invoke({ query: state.query })
}

/**
 * 4ï¸âƒ£ Calculator Node (math)
 */
async function calculatorNode(state: typeof StateAnnotation.State) {
  try {
    // naive numeric eval (for demo)
    const expression = state.query.replace(/[^\d+\-*/().]/g, '')
    // eslint-disable-next-line no-eval
    const result = eval(expression)
    return { result: `ğŸ§® The result is ${result}` }
  } catch {
    return { result: 'âŒ Invalid math expression.' }
  }
}

/**
 * 5ï¸âƒ£ Build Graph
 */
const workflow = new StateGraph(StateAnnotation)
  .addNode('router', routerNode)
  .addNode('answerer', answerNode)
  .addNode('calculator', calculatorNode)
  .addEdge('__start__', 'router')
  .addConditionalEdges('router', (state) => state.route, {
    general: 'answerer',
    math: 'calculator',
  })
  .addEdge('answerer', END)
  .addEdge('calculator', END)

const app = workflow.compile()

/**
 * 6ï¸âƒ£ Run Example
 */
async function main() {
  const cases = ['Who discovered gravity?', 'What is 25 * 6?']

  for (const q of cases) {
    console.log(`\nğŸ’¬ User: ${q}`)
    const output = await app.invoke({ query: q })
    console.log('ğŸ¤– Response:', output.result)
  }
}

main()
```

---

## âœ… **Expected Output**

```
ğŸ’¬ User: Who discovered gravity?
ğŸ§­ Routing to: general
ğŸ¤– Response: Isaac Newton discovered gravity.

ğŸ’¬ User: What is 25 * 6?
ğŸ§­ Routing to: math
ğŸ¤– Response: ğŸ§® The result is 150
```

---

## ğŸ§© **How It Works**

| Node       | Input           | Output          | Behavior            |
| ---------- | --------------- | --------------- | ------------------- |
| Router     | User question   | route (string)  | Decides branch      |
| Answerer   | route = general | result (string) | Uses LLM            |
| Calculator | route = math    | result (string) | Uses JS eval        |
| Graph      | Merges result   | Final output    | Clean orchestration |

---

## âš™ï¸ **LangGraph Feature Highlight**

| Concept               | Meaning                                                       |
| --------------------- | ------------------------------------------------------------- |
| **Conditional Edges** | Define edge routing based on runtime state                    |
| **Branch Execution**  | Only executes the node matching the key                       |
| **Dynamic Flow**      | Easily extensible â€” add â€œweatherâ€, â€œtoolâ€, or â€œsearchâ€ routes |
| **Declarative Logic** | Routing condition is pure function `(state) => key`           |

---

## ğŸ§  **Real-World Applications**

- Route between:

  - RAG node vs normal LLM node
  - Tool node vs memory recall
  - Planner vs executor agents

- Combine with streaming to visualize routing live

---

## ğŸ§¾ **Quick Revision Notes**

âœ… `addConditionalEdges(node, conditionFn, mapping)` â†’ key LangGraph API
âœ… Condition function returns a key in the mapping
âœ… Enables **decision trees, routers, classifiers**
âœ… Great for **intent classification**, **tool selection**, or **query typing**
