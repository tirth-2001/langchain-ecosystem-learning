# ‚úÖ 7.1.1 ‚Äî LangGraph Mental Model & Hello Graph

## üéØ Goal

Understand:

- What LangGraph is
- Why it exists (vs LangChain Agents)
- Core primitives: **State ‚Üí Node ‚Üí Edge ‚Üí Executor**
- Build the simplest working graph

---

## üß† Concept: What is LangGraph?

LangGraph = **State Machine + AI Agent framework**

Think of it like:

| Concept      | Means                                    |
| ------------ | ---------------------------------------- |
| Agent prompt | ü§û ‚ÄúHope LLM picks right actions‚Äù        |
| LangGraph    | ‚úÖ ‚ÄúDefine exact workflow & state rules‚Äù |

> Instead of ‚ÄúLLM guesses steps‚Äù, you **define steps and let LLM fill intelligence inside nodes**.

---

### üß© LangGraph is built around:

| Concept               | Meaning                                     |
| --------------------- | ------------------------------------------- |
| ‚úÖ **Nodes**          | Steps (LLM call, tool call, DB fetch, etc.) |
| ‚úÖ **Edges**          | Transitions                                 |
| ‚úÖ **State**          | Shared memory passed between nodes          |
| ‚úÖ **Graph Executor** | Runs the flow deterministically             |

---

### üß† Simple analogy

| Building App With | Feels Like                                           |
| ----------------- | ---------------------------------------------------- |
| LLM prompt        | Talking to a smart person and hoping they follow     |
| LangChain agent   | Giving that person tools                             |
| **LangGraph**     | Giving them a **workflow chart + policies + memory** |

This gives:

- Reliability
- Control
- Observability
- Pause/resume
- Multi-agent systems

---

## üß≠ Mental Diagram

```
(State Input)
     ‚Üì
 [ Node A ] ‚Üí (updates state)
     ‚Üì
 [ Node B ]
     ‚Üì
  Output
```

That's it for the first lesson.

---

## üõ†Ô∏è **Code: Hello LangGraph**

### File: `src/langgraph/7.1.1-hello-graph.ts`

```ts
import { StateGraph, END } from '@langchain/langgraph'

// 1) Define the state structure
type State = {
  message: string
}

// 2) Node: the operation to run
async function helloNode(state: State) {
  return {
    message: `Hello from LangGraph! Input was: ${state.message}`,
  }
}

// 3) Build the graph
const workflow = new StateGraph<State>({
  channels: {
    message: {
      value: (x: string) => x,
    },
  },
})
  .addNode('hello', helloNode)
  .addEdge('hello', END)
  .addEntry('hello')

// 4) Compile the graph
const app = workflow.compile()

async function main() {
  const result = await app.invoke({
    message: 'This is my first LangGraph flow',
  })

  console.log('‚úÖ Output:', result)
}

main()
```

---

## ‚ñ∂Ô∏è Run

```
npx ts-node src/langgraph/7.1.1-hello-graph.ts
```

---

## ‚úÖ Expected Output

```
‚úÖ Output: {
  message: 'Hello from LangGraph! Input was: This is my first LangGraph flow'
}
```

---

## üß† Key Understanding

| Concept | You Learned                 |
| ------- | --------------------------- |
| State   | Object passed through graph |
| Node    | Function that updates state |
| Edge    | Transition to next node     |
| Entry   | Start point                 |
| END     | Stop execution              |

No LLM yet ‚Äî just workflow bones.

We master **structure before intelligence**.

---

## ‚ö†Ô∏è Common Beginner Traps

| Mistake                  | Fix                                           |
| ------------------------ | --------------------------------------------- |
| Thinking graph = chain   | Graphs ‚Üí branching + loops                    |
| Expecting LLM every step | Graph controls flow, nodes can be plain logic |
| Forgetting state shape   | State typing is strict (good!)                |

---

## üßæ Quick Revision Notes

- LangGraph = **workflow engine for AI**
- You define **nodes & rules**
- Graph executes **deterministically**
- State flows between nodes
- This makes AI systems **modular, debuggable, reliable**
