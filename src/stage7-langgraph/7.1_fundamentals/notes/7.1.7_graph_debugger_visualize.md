# ğŸ•µï¸â€â™‚ï¸ **7.1.7 â€” Graph Debugger & Visualization (Inspect State Transitions)**

---

## ğŸ¯ **Goal**

Enable **live introspection** of LangGraph execution:

- Track **state evolution** after each node
- Log **transitions** and **conditional routing**
- Optionally export **graph structure (DAG)** for visualization
- Build foundation for **UI graph inspector (Stage 7.6)**

---

## ğŸ§  **Why This Matters**

LangGraph is deterministic â€” meaning the entire agent reasoning path can be visualized.

In complex graphs:

- Youâ€™ll have **branches**, **loops**, and **conditional flows**
- Without visualization, debugging becomes a nightmare ğŸ˜…
- So this stage builds tools to **trace, monitor, and visualize**

---

## ğŸ§© **Weâ€™ll Do 3 Things**

| Part | Focus                | Output                                     |
| ---- | -------------------- | ------------------------------------------ |
| ğŸ§¾ A | Console Debugger     | Logs nodes, transitions, and state changes |
| ğŸ” B | JSON Event Collector | Records structured execution logs          |
| ğŸ§­ C | Graph Visualization  | Export `.dot` graph or render structure    |

---

## ğŸ’» **Implementation**

### ğŸ“ `src/langgraph/7.1.7-debugger-graph.ts`

```ts
import { StateGraph, Annotation, END } from '@langchain/langgraph'
import { ChatOpenAI } from '@langchain/openai'
import { ChatPromptTemplate } from '@langchain/core/prompts'
import { RunnableSequence } from '@langchain/core/runnables'
import fs from 'fs'
import dotenv from 'dotenv'
dotenv.config()

/**
 * 1ï¸âƒ£ Define State
 */
const StateAnnotation = Annotation.Root({
  input: Annotation<string>({ reducer: (_, next) => next }),
  summary: Annotation<string>({ reducer: (_, next) => next }),
})

/**
 * 2ï¸âƒ£ Define Nodes
 */
const model = new ChatOpenAI({ modelName: 'gpt-4o-mini', temperature: 0.3 })

const summarizePrompt = ChatPromptTemplate.fromTemplate(`
Summarize the following user text in one concise sentence:
{text}
`)

const summarizeChain = RunnableSequence.from([summarizePrompt, model, (out) => out.content.trim()])

async function summarizeNode(state: typeof StateAnnotation.State) {
  const summary = await summarizeChain.invoke({ text: state.input })
  return { summary }
}

async function logNode(state: typeof StateAnnotation.State) {
  console.log('ğŸ“˜ Final summary:', state.summary)
  return state
}

/**
 * 3ï¸âƒ£ Build Graph
 */
const workflow = new StateGraph(StateAnnotation)
  .addNode('summarizer', summarizeNode)
  .addNode('logger', logNode)
  .addEdge('__start__', 'summarizer')
  .addEdge('summarizer', 'logger')
  .addEdge('logger', END)

const app = workflow.compile()

/**
 * 4ï¸âƒ£ Debugger Hook
 */
async function runWithDebugger(input: string) {
  const logFile = './graph-debug.json'
  const debugData: any[] = []

  console.log('ğŸš€ Executing graph...\n')

  const listener = app.stream(
    { input },
    {
      callbacks: [
        {
          handleEvent: async (event) => {
            const { event: eventType, name, data } = event
            if (eventType && name) {
              console.log(`ğŸ§© ${eventType} @ ${name}`)
            }
            // Log event for later inspection
            debugData.push({
              time: new Date().toISOString(),
              event: eventType,
              node: name,
              data,
            })
          },
        },
      ],
    },
  )

  for await (const step of listener) {
    // Graph emits multiple events â€” on_start, on_node_end, etc.
    if (step?.state) {
      console.log('ğŸ”„ State Snapshot:', step.state)
    }
  }

  fs.writeFileSync(logFile, JSON.stringify(debugData, null, 2))
  console.log(`\nğŸª¶ Debug log written to ${logFile}`)
}

/**
 * 5ï¸âƒ£ Run Example
 */
await runWithDebugger('LangGraph enables structured reasoning for AI agents.')
```

---

## âœ… **Expected Output**

Console (real-time execution trace):

```
ğŸš€ Executing graph...

ğŸ§© on_start @ summarizer
ğŸ”„ State Snapshot: { input: "LangGraph enables structured reasoning for AI agents." }

ğŸ§© on_node_end @ summarizer
ğŸ”„ State Snapshot: {
  input: "LangGraph enables structured reasoning for AI agents.",
  summary: "LangGraph helps AI reason in structured workflows."
}

ğŸ§© on_node_end @ logger
ğŸ“˜ Final summary: LangGraph helps AI reason in structured workflows.
ğŸª¶ Debug log written to graph-debug.json
```

---

## ğŸ§¾ **graph-debug.json (sample)**

```json
[
  {
    "time": "2025-11-06T18:42:12.222Z",
    "event": "on_start",
    "node": "summarizer",
    "data": {}
  },
  {
    "time": "2025-11-06T18:42:13.884Z",
    "event": "on_node_end",
    "node": "summarizer",
    "data": {
      "summary": "LangGraph helps AI reason in structured workflows."
    }
  }
]
```

---

## ğŸ§© **Optional: Graph Visualization**

LangGraph supports exporting the compiled DAG as DOT (Graphviz) format.

```ts
import { writeFileSync } from 'fs'
writeFileSync('./workflow.dot', app.getGraph().toDot())
console.log('ğŸ§­ Graph structure exported to workflow.dot')
```

Then visualize via:

```bash
npx graphviz-cli workflow.dot workflow.png
```

This generates a flow diagram:

```
[__start__] â†’ [summarizer] â†’ [logger] â†’ [END]
```

---

## ğŸ§  **Real-World Debug Patterns**

| Use Case           | What to Inspect                   |
| ------------------ | --------------------------------- |
| Loops & retries    | Number of iterations, exit reason |
| Conditional routes | Which branch was taken            |
| Tool nodes         | Tool usage, response latency      |
| Agent planning     | Step-by-step thought process      |
| Streaming runs     | Partial output generation         |

---

## âš™ï¸ **Best Practices**

âœ… Always attach `callbacks` to monitor events
âœ… Stream event flow for long-running graphs
âœ… Persist debug logs for postmortem inspection
âœ… Export `.dot` graphs for complex DAGs
âœ… Use consistent logging patterns across nodes

---

## ğŸ§¾ **Quick Revision Notes**

| Concept               | Summary                                        |
| --------------------- | ---------------------------------------------- |
| `app.stream()`        | Executes graph and emits node lifecycle events |
| Event hooks           | `on_start`, `on_node_end`, `on_error`, etc.    |
| `callbacks`           | Custom listener for real-time debugging        |
| `.getGraph().toDot()` | Export visual graph diagram                    |
| Debug file            | Record transitions for replay                  |

---

## ğŸ§© **Output of Stage 7.1**

You now have mastered:

âœ… LangGraph mental model
âœ… Node creation and state management
âœ… Multi-node chaining
âœ… Memory node & context
âœ… Conditional routing
âœ… Looping & retries
âœ… Graph debugging & visualization

---

### ğŸ¯ **Outcome**

You can now:

- **Design**, **debug**, and **visualize** LangGraph DAGs
- Build **self-looping**, **conditional**, **memory-driven** workflows
- Use event streaming for **real-time graph tracing**
