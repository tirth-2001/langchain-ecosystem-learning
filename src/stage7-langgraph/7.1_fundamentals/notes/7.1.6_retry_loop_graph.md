# ğŸ§  **7.1.6 â€” Looping + Retry (Self-Loop until Goal Achieved)**

---

## ğŸ¯ **Goal**

Build a LangGraph that:

- Takes a **goal or task** as input
- **Plans next steps**, executes them, evaluates results
- **Loops** until the goal is completed (or retry limit reached)

### ğŸ§© Core Idea

The graph will include:

1. A **Planner Node** â†’ decides the next step
2. A **Worker Node** â†’ executes that step
3. A **Checker Node** â†’ evaluates whether the goal is done
4. A **Loop Edge** â†’ goes back to `Planner` if not complete

---

## ğŸ§© **Visual Flow**

```
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  Planner Node â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†“
          [ Worker Node ]
                  â†“
          [ Checker Node ]
             â”œâ”€â”€ done â†’ END
             â””â”€â”€ not_done â†’ (loop back to Planner)
```

---

## âš™ï¸ **Concepts Introduced**

| Concept                  | Meaning                             |
| ------------------------ | ----------------------------------- |
| **Self-loop**            | Edge routing back to previous node  |
| **Retry Policy**         | Repeat attempts until success       |
| **State Mutation**       | Persist progress between iterations |
| **Goal-driven Planning** | Model evaluates whether to continue |

---

## ğŸ’» **Implementation**

### ğŸ“ `src/langgraph/7.1.6-looping-graph.ts`

```ts
import { StateGraph, Annotation, END } from '@langchain/langgraph'
import { ChatPromptTemplate } from '@langchain/core/prompts'
import { ChatOpenAI } from '@langchain/openai'
import { RunnableSequence } from '@langchain/core/runnables'
import dotenv from 'dotenv'
dotenv.config()

/**
 * 1ï¸âƒ£ Define State
 */
const StateAnnotation = Annotation.Root({
  goal: Annotation<string>({ reducer: (curr, next) => next }),
  step: Annotation<string>({ reducer: (curr, next) => next }),
  result: Annotation<string>({ reducer: (curr, next) => next }),
  done: Annotation<boolean>({ reducer: (curr, next) => next }),
  iterations: Annotation<number>({ reducer: (curr, next) => next }),
})

/**
 * 2ï¸âƒ£ Define Models
 */
const model = new ChatOpenAI({
  modelName: 'gpt-4o-mini',
  temperature: 0.5,
})

/**
 * 3ï¸âƒ£ Planner Node â†’ decides next step
 */
const plannerPrompt = ChatPromptTemplate.fromTemplate(`
You are a task planner working towards a goal: "{goal}".
Think step by step. Suggest the next best action.

If you think the goal is achieved, reply ONLY with: DONE
Otherwise, reply with one actionable next step.
`)

const plannerChain = RunnableSequence.from([plannerPrompt, model, (out) => out.content.trim()])

async function plannerNode(state: typeof StateAnnotation.State) {
  const nextStep = await plannerChain.invoke({ goal: state.goal })
  if (nextStep.toUpperCase() === 'DONE') {
    return { done: true }
  }
  console.log('ğŸ§  Planning next step:', nextStep)
  return { step: nextStep, iterations: (state.iterations || 0) + 1 }
}

/**
 * 4ï¸âƒ£ Worker Node â†’ executes the step (simulation)
 */
async function workerNode(state: typeof StateAnnotation.State) {
  const step = state.step
  const simulatedResult = `âœ… Executed step: ${step}`
  console.log('âš™ï¸ Worker executing:', simulatedResult)
  return { result: simulatedResult }
}

/**
 * 5ï¸âƒ£ Checker Node â†’ decides if loop should continue
 */
const checkerPrompt = ChatPromptTemplate.fromTemplate(`
You are a checker.
Given the goal "{goal}" and the last result "{result}",
decide if the goal is achieved.

Reply with only: done or not_done
`)

const checkerChain = RunnableSequence.from([checkerPrompt, model, (out) => out.content.trim().toLowerCase()])

async function checkerNode(state: typeof StateAnnotation.State) {
  const verdict = await checkerChain.invoke({
    goal: state.goal,
    result: state.result,
  })
  console.log('ğŸ§© Checker verdict:', verdict)
  return { done: verdict === 'done' }
}

/**
 * 6ï¸âƒ£ Build Graph with Looping Edge
 */
const graph = new StateGraph(StateAnnotation)
  .addNode('planner', plannerNode)
  .addNode('worker', workerNode)
  .addNode('checker', checkerNode)
  .addEdge('__start__', 'planner')
  .addEdge('planner', 'worker')
  .addEdge('worker', 'checker')
  .addConditionalEdges(
    'checker',
    (state) => (state.done ? 'done' : state.iterations > 5 ? 'max_retries' : 'continue'),
    {
      done: END,
      continue: 'planner',
      max_retries: END,
    },
  )

const app = graph.compile()

/**
 * 7ï¸âƒ£ Run Demo
 */
async function main() {
  console.log('ğŸ§­ Starting Looping Graph Demo...\n')

  const result = await app.invoke({
    goal: 'Write a 3-step plan to organize my morning routine.',
  })

  console.log('\nğŸ Final State:')
  console.log(result)
}

main()
```

---

## âœ… **Expected Output**

```
ğŸ§­ Starting Looping Graph Demo...

ğŸ§  Planning next step: 1. Wake up and make your bed
âš™ï¸ Worker executing: âœ… Executed step: 1. Wake up and make your bed
ğŸ§© Checker verdict: not_done
ğŸ§  Planning next step: 2. Brush your teeth and freshen up
âš™ï¸ Worker executing: âœ… Executed step: 2. Brush your teeth and freshen up
ğŸ§© Checker verdict: not_done
ğŸ§  Planning next step: DONE
ğŸ Final State:
{
  goal: 'Write a 3-step plan to organize my morning routine.',
  step: 'DONE',
  done: true,
  result: 'âœ… Executed step: 2. Brush your teeth and freshen up',
  iterations: 3
}
```

---

## ğŸ§  **How the Loop Works**

| Node        | Role                   | Behavior                            |
| ----------- | ---------------------- | ----------------------------------- |
| **Planner** | Thinks next step       | Adds to `iterations`, proposes next |
| **Worker**  | Executes step          | Returns a textual result            |
| **Checker** | Evaluates progress     | Returns `done / not_done`           |
| **Graph**   | Uses conditional edges | Loops or exits                      |

---

## âš™ï¸ **Why This Is Important**

| Concept                       | Real-World Parallel                    |
| ----------------------------- | -------------------------------------- |
| **Loop Edge**                 | Retry logic, recursive reasoning       |
| **Plannerâ€“Executorâ€“Checker**  | Same as AutoGPT / CrewAI loop          |
| **Goal Completion Condition** | Logical or semantic stopping rule      |
| **Iteration Counter**         | Prevents infinite loops (safety limit) |

---

## ğŸ’¡ **Extensions (Next-Level Ideas)**

- Add **RAG node** between Planner â†’ Worker â†’ Checker for factual grounding
- Use **Tool node** (calculator, API) instead of dummy worker
- Replace Checker with a **reward evaluator** (like reinforcement loop)
- Store iteration history in Mongo for persistence

---

## ğŸ§¾ **Quick Revision Notes**

âœ… `addConditionalEdges()` supports **looping and retries**
âœ… `state.done` determines flow â†’ `END` or re-enter planner
âœ… Always include an **iteration limit** for safety
âœ… This pattern = foundation of **AutoGPT**, **LangGraph Planner**, **CrewAI loops**
