# **6.1.4 – Task Controller & LangChain Integration**

## 🧭 **Goal of 6.1.4**

Create a backend module that:

- Introduces a `Task` domain model (in-memory for now)
- Provides CRUD endpoints (`/api/tasks`)
- Integrates LangChain calls so each task can _run_ a chain/tool/agent
- Returns progress + result in a structured format

Later (Stage 6.3) this same structure will plug into **MongoDB persistence** and **frontend dashboards**.

---

## 📁 **Folder Setup**

Inside `src/` create:

```
controllers/
 └── taskController.ts
routes/
 └── taskRoutes.ts
services/
 └── taskService.ts
langchain/
 └── chains/
     └── taskChain.ts
types/
 └── task.d.ts
```

---

## 🧩 **1. Task Model (in-memory)**

`src/types/task.d.ts`

```ts
export interface Task {
  id: string
  title: string
  description?: string
  status: 'pending' | 'running' | 'completed' | 'failed'
  result?: any
  createdAt: Date
  updatedAt: Date
}
```

---

## ⚙️ **2. Service Layer**

`src/services/taskService.ts`

```ts
import { Task } from '../types/task'
import { v4 as uuid } from 'uuid'

const tasks: Task[] = []

export const createTask = (title: string, description?: string): Task => {
  const task: Task = {
    id: uuid(),
    title,
    description,
    status: 'pending',
    createdAt: new Date(),
    updatedAt: new Date(),
  }
  tasks.push(task)
  return task
}

export const listTasks = () => tasks

export const getTask = (id: string) => tasks.find((t) => t.id === id)

export const updateTask = (id: string, updates: Partial<Task>) => {
  const idx = tasks.findIndex((t) => t.id === id)
  if (idx === -1) return null
  tasks[idx] = { ...tasks[idx], ...updates, updatedAt: new Date() }
  return tasks[idx]
}

export const deleteTask = (id: string) => {
  const idx = tasks.findIndex((t) => t.id === id)
  if (idx === -1) return false
  tasks.splice(idx, 1)
  return true
}
```

---

## 🤖 **3. LangChain Integration Layer**

`src/langchain/chains/taskChain.ts`

```ts
import { ChatOpenAI } from '@langchain/openai'
import { PromptTemplate, LLMChain } from 'langchain'
import dotenv from 'dotenv'
dotenv.config()

const llm = new ChatOpenAI({
  modelName: process.env.OPENAI_MODEL ?? 'gpt-4o-mini',
  temperature: 0.7,
  openAIApiKey: process.env.OPENAI_API_KEY,
})

const prompt = PromptTemplate.fromTemplate(
  `You are an assistant performing a task.\nTask description: {description}\nGive your concise output.`,
)

export const runTaskChain = async (description: string) => {
  const chain = new LLMChain({ llm, prompt })
  const result = await chain.call({ description })
  return result.text
}
```

---

## 🧠 **4. Controller**

`src/controllers/taskController.ts`

```ts
import { Request, Response } from 'express'
import * as taskService from '../services/taskService'
import { runTaskChain } from '../langchain/chains/taskChain'

export const create = async (req: Request, res: Response) => {
  const { title, description } = req.body
  const task = taskService.createTask(title, description)
  res.status(201).json(task)
}

export const list = (req: Request, res: Response) => {
  res.json(taskService.listTasks())
}

export const run = async (req: Request, res: Response) => {
  const { id } = req.params
  const task = taskService.getTask(id)
  if (!task) return res.status(404).json({ error: 'Task not found' })

  try {
    taskService.updateTask(id, { status: 'running' })
    const output = await runTaskChain(task.description || '')
    taskService.updateTask(id, { status: 'completed', result: output })
    res.json(taskService.getTask(id))
  } catch (err: any) {
    taskService.updateTask(id, { status: 'failed', result: err.message })
    res.status(500).json({ error: err.message })
  }
}

export const remove = (req: Request, res: Response) => {
  const { id } = req.params
  const ok = taskService.deleteTask(id)
  res.status(ok ? 204 : 404).end()
}
```

---

## 🌐 **5. Routes**

`src/routes/taskRoutes.ts`

```ts
import { Router } from 'express'
import * as controller from '../controllers/taskController'

const router = Router()

router.get('/', controller.list)
router.post('/', controller.create)
router.post('/:id/run', controller.run)
router.delete('/:id', controller.remove)

export default router
```

And register it in `app.ts`:

```ts
import taskRoutes from './routes/taskRoutes'
app.use('/api/tasks', taskRoutes)
```

---

## ✅ **6. Test Endpoints**

Use Postman or `curl`:

```bash
# Create
curl -X POST http://localhost:3000/api/tasks \
     -H "Content-Type: application/json" \
     -d '{"title":"Summarize","description":"Summarize AI trends"}'

# List
curl http://localhost:3000/api/tasks

# Run
curl -X POST http://localhost:3000/api/tasks/<id>/run
```

Response:

```json
{
  "id": "1234",
  "title": "Summarize",
  "status": "completed",
  "result": "AI trends include multimodal models, agentic systems, and edge AI.",
  "createdAt": "...",
  "updatedAt": "..."
}
```

---

## 🔮 **7. Optional Enhancements**

| Enhancement               | Purpose                                                   |
| ------------------------- | --------------------------------------------------------- |
| **Async job execution**   | Use background worker (e.g., BullMQ) to run heavy tasks   |
| **Streaming task result** | Reuse SSE logic from 6.1.3 for live progress              |
| **Task type registry**    | Map different task kinds → chain/tool/agent automatically |
| **Persistence**           | Replace in-memory array with MongoDB (Stage 6.3)          |

---

### 🎯 **Deliverable for 6.1.4**

- `/api/tasks` CRUD operational
- `/api/tasks/:id/run` executes LangChain chain
- Logs and updates task status in real time
- Modular structure ready for **frontend orchestration** and **database persistence**
