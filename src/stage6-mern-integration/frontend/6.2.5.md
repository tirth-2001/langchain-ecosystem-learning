## âš™ï¸ 6.2.5 â€” Task Management UI (Aligned to Existing System)

### ðŸŽ¯ **Objective**

Enhance your existing task system with:

- **Full CRUD support** (create, run, delete, fetch)
- **UI for creating & managing tasks**
- **Progress & result tracking**
- **Visual feedback** for task status
- **Polling mechanism** for live updates when tasks are running (since thereâ€™s no SSE)

---

## ðŸ§© Updated Architecture Overview

### ðŸ”¸ Components / Hooks / Context

| Layer                     | Responsibility                                                                                                      |
| :------------------------ | :------------------------------------------------------------------------------------------------------------------ |
| **`TaskContext`**         | Already manages fetching/creating tasks â†’ weâ€™ll extend it with `runTask`, `deleteTask`, and a `pollTasks` function. |
| **`useTasks()` hook**     | Consumer hook to access the TaskContext easily.                                                                     |
| **`TaskList.tsx`**        | Main UI table/list showing all tasks with status, action buttons, and result.                                       |
| **`TaskForm.tsx`**        | Modal or inline form to create new tasks (title + description).                                                     |
| **`TaskStatusBadge.tsx`** | Small component to visually represent task state.                                                                   |
| **`TaskResultModal.tsx`** | Popup or collapsible area to show the task result once completed.                                                   |

---

## ðŸ§  Step 1 â€” Extend `tasks.api.ts`

Weâ€™ll add missing endpoints for `run` and `delete` operations to match backend routes.

```ts
// tasks.api.ts
import apiClient from '../client'
import type { ApiResponse, Task } from '../types'

export const getAllTasks = async () => {
  const res = await apiClient.get<ApiResponse<Task[]>>('/tasks')
  return res.data
}

export const createTask = async (task: Omit<Task, 'id' | 'createdAt' | 'status'>) => {
  const res = await apiClient.post<ApiResponse<Task>>('/tasks', task)
  return res.data
}

export const runTask = async (id: string) => {
  const res = await apiClient.post<ApiResponse<Task>>(`/tasks/${id}/run`)
  return res.data
}

export const deleteTask = async (id: string) => {
  await apiClient.delete(`/tasks/${id}`)
}
```

---

## ðŸ§  Step 2 â€” Extend `TaskContext`

Weâ€™ll add:

- `runTask(id)`
- `deleteTask(id)`
- `pollTasks()` â€” periodically re-fetch all tasks to keep UI updated during long runs.

```ts
// TaskContext.tsx
import { useState, useEffect, type ReactNode } from 'react'
import { createTask, getAllTasks, runTask, deleteTask } from '../api/endpoints/tasks.api'
import { handleApiError } from '../utils/errorHandler'
import type { Task } from '../api/types'
import { TaskContext } from '../hooks'

export const TaskProvider = ({ children }: { children: ReactNode }) => {
  const [tasks, setTasks] = useState<Task[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const fetchTasks = async () => {
    setLoading(true)
    try {
      const res = await getAllTasks()
      setTasks(res.data)
    } catch (err) {
      setError(handleApiError(err))
    } finally {
      setLoading(false)
    }
  }

  const addTask = async (title: string, description: string) => {
    setLoading(true)
    try {
      const res = await createTask({ title, description })
      setTasks((prev) => [...prev, res.data])
    } catch (err) {
      setError(handleApiError(err))
    } finally {
      setLoading(false)
    }
  }

  const runExistingTask = async (id: string) => {
    try {
      const res = await runTask(id)
      setTasks((prev) => prev.map((t) => (t.id === id ? res.data : t)))
    } catch (err) {
      setError(handleApiError(err))
    }
  }

  const deleteExistingTask = async (id: string) => {
    try {
      await deleteTask(id)
      setTasks((prev) => prev.filter((t) => t.id !== id))
    } catch (err) {
      setError(handleApiError(err))
    }
  }

  // Polling for status updates every 5 seconds
  const pollTasks = () => {
    const interval = setInterval(fetchTasks, 5000)
    return () => clearInterval(interval)
  }

  useEffect(() => {
    fetchTasks()
    const stopPolling = pollTasks()
    return stopPolling
  }, [])

  return (
    <TaskContext.Provider
      value={{
        tasks,
        loading,
        error,
        fetchTasks,
        addTask,
        runExistingTask,
        deleteExistingTask,
      }}
    >
      {children}
    </TaskContext.Provider>
  )
}
```

---

## ðŸ§  Step 3 â€” Create `useTasks` Hook

Simple wrapper to consume context:

```ts
// useTasks.ts
import { useContext } from 'react'
import { TaskContext } from '../context/TaskContext'

export const useTasks = () => {
  const ctx = useContext(TaskContext)
  if (!ctx) throw new Error('useTasks must be used inside a TaskProvider')
  return ctx
}
```

---

## ðŸ§  Step 4 â€” UI Components

### âœ… `TaskList.tsx`

```tsx
import { useTasks } from '../hooks/useTasks'
import { TaskStatusBadge } from './TaskStatusBadge'

export const TaskList = () => {
  const { tasks, loading, runExistingTask, deleteExistingTask } = useTasks()

  if (loading) return <p>Loading tasks...</p>

  return (
    <div className="p-4">
      <table className="min-w-full border-collapse border border-gray-300">
        <thead>
          <tr className="bg-gray-100">
            <th className="p-2">Title</th>
            <th className="p-2">Description</th>
            <th className="p-2">Status</th>
            <th className="p-2">Actions</th>
          </tr>
        </thead>
        <tbody>
          {tasks.map((t) => (
            <tr key={t.id} className="border-t">
              <td className="p-2">{t.title}</td>
              <td className="p-2">{t.description}</td>
              <td className="p-2">
                <TaskStatusBadge status={t.status} />
              </td>
              <td className="p-2 space-x-2">
                <button
                  className="px-3 py-1 bg-blue-500 text-white rounded"
                  disabled={t.status === 'running'}
                  onClick={() => runExistingTask(t.id)}
                >
                  Run
                </button>
                <button className="px-3 py-1 bg-red-500 text-white rounded" onClick={() => deleteExistingTask(t.id)}>
                  Delete
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  )
}
```

---

### âœ… `TaskForm.tsx`

```tsx
import { useState } from 'react'
import { useTasks } from '../hooks/useTasks'

export const TaskForm = () => {
  const { addTask } = useTasks()
  const [title, setTitle] = useState('')
  const [description, setDescription] = useState('')

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (!title.trim()) return
    addTask(title, description)
    setTitle('')
    setDescription('')
  }

  return (
    <form onSubmit={handleSubmit} className="flex flex-col gap-2 p-4">
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Task Title"
        className="border p-2 rounded"
      />
      <textarea
        value={description}
        onChange={(e) => setDescription(e.target.value)}
        placeholder="Task Description"
        className="border p-2 rounded"
      />
      <button className="bg-green-600 text-white px-3 py-2 rounded">Create Task</button>
    </form>
  )
}
```

---

### âœ… `TaskStatusBadge.tsx`

```tsx
export const TaskStatusBadge = ({ status }: { status: string }) => {
  const color =
    status === 'completed'
      ? 'bg-green-200 text-green-800'
      : status === 'running'
      ? 'bg-yellow-200 text-yellow-800'
      : status === 'failed'
      ? 'bg-red-200 text-red-800'
      : 'bg-gray-200 text-gray-800'

  return <span className={`px-2 py-1 rounded text-sm font-medium ${color}`}>{status}</span>
}
```

---

## ðŸ§  Step 5 â€” Combine Everything

```tsx
// TaskManager.tsx
import { TaskForm } from './TaskForm'
import { TaskList } from './TaskList'

export const TaskManager = () => (
  <div className="space-y-6">
    <h1 className="text-xl font-bold">Task Manager</h1>
    <TaskForm />
    <TaskList />
  </div>
)
```

Wrap with your provider:

```tsx
import { TaskProvider } from '../context/TaskContext'
import { TaskManager } from '../components/TaskManager'

export const TaskPage = () => (
  <TaskProvider>
    <TaskManager />
  </TaskProvider>
)
```

---

## âœ… Final Outcome

| Goal                 | Status                                                         |
| :------------------- | :------------------------------------------------------------- |
| Fetch & create tasks | âœ… Already supported                                           |
| Run & delete tasks   | âœ… Added                                                       |
| Polling for updates  | âœ… Added                                                       |
| Visual feedback      | âœ… Status badges + buttons                                     |
| Async tracking       | âœ… via polling (5 s interval)                                  |
| Result view          | ðŸŸ¡ (can be added easily next with modal or expandable section) |

---

Perfect âœ… â€” this addition will **complete Stage 6.2.5** with a clean, production-grade UX for viewing **task results inline or via a modal**.
Weâ€™ll go with a **hybrid approach** â€” inline collapsible result section (lightweight) + optional modal for expanded view (for long outputs).

Below is the **final upgrade** for your Task Management UI.

---

## ðŸ§© Extended Goal

> Enable users to view each taskâ€™s **result output** once itâ€™s completed.
>
> - Inline expansion (collapsible row under task)
> - Optional â€œView Resultâ€ modal for long LLM outputs
> - Handles errors gracefully (`failed` status)

---

## ðŸ§  Step 1 â€” Add a lightweight modal component

Weâ€™ll reuse Tailwind + minimal logic.

```tsx
// components/TaskResultModal.tsx
import { useEffect } from 'react'

interface TaskResultModalProps {
  open: boolean
  onClose: () => void
  title: string
  result?: string
  status: string
}

export const TaskResultModal = ({ open, onClose, title, result, status }: TaskResultModalProps) => {
  useEffect(() => {
    const handleEsc = (e: KeyboardEvent) => e.key === 'Escape' && onClose()
    document.addEventListener('keydown', handleEsc)
    return () => document.removeEventListener('keydown', handleEsc)
  }, [onClose])

  if (!open) return null

  return (
    <div className="fixed inset-0 flex items-center justify-center bg-black/40 z-50">
      <div className="bg-white rounded-xl shadow-xl w-full max-w-2xl p-6">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-lg font-semibold">{title}</h2>
          <button onClick={onClose} className="text-gray-500 hover:text-gray-800">
            âœ•
          </button>
        </div>
        <div className="border rounded p-3 max-h-96 overflow-y-auto whitespace-pre-wrap text-sm font-mono">
          {status === 'failed' ? (
            <span className="text-red-600 font-semibold">{result || 'Task failed'}</span>
          ) : (
            <>{result || 'No result yet.'}</>
          )}
        </div>
      </div>
    </div>
  )
}
```

---

## ðŸ§  Step 2 â€” Add inline expansion and modal trigger in `TaskList`

Weâ€™ll give each row a **â€œView Resultâ€** button (enabled if status is `completed` or `failed`),
and clicking it either toggles inline view or opens modal for full output.

```tsx
// components/TaskList.tsx
import { useState } from 'react'
import { useTasks } from '../hooks/useTasks'
import { TaskStatusBadge } from './TaskStatusBadge'
import { TaskResultModal } from './TaskResultModal'

export const TaskList = () => {
  const { tasks, loading, runExistingTask, deleteExistingTask } = useTasks()
  const [expandedTask, setExpandedTask] = useState<string | null>(null)
  const [modalTask, setModalTask] = useState<string | null>(null)

  if (loading) return <p>Loading tasks...</p>

  return (
    <div className="p-4">
      <table className="min-w-full border-collapse border border-gray-300">
        <thead>
          <tr className="bg-gray-100">
            <th className="p-2 text-left">Title</th>
            <th className="p-2 text-left">Description</th>
            <th className="p-2 text-left">Status</th>
            <th className="p-2 text-left">Actions</th>
          </tr>
        </thead>
        <tbody>
          {tasks.map((t) => (
            <>
              <tr key={t.id} className="border-t">
                <td className="p-2 font-medium">{t.title}</td>
                <td className="p-2">{t.description}</td>
                <td className="p-2">
                  <TaskStatusBadge status={t.status} />
                </td>
                <td className="p-2 space-x-2">
                  <button
                    className="px-3 py-1 bg-blue-500 text-white rounded"
                    disabled={t.status === 'running'}
                    onClick={() => runExistingTask(t.id)}
                  >
                    Run
                  </button>
                  <button className="px-3 py-1 bg-red-500 text-white rounded" onClick={() => deleteExistingTask(t.id)}>
                    Delete
                  </button>
                  {(t.status === 'completed' || t.status === 'failed') && (
                    <button
                      className="px-3 py-1 bg-gray-600 text-white rounded"
                      onClick={() => setExpandedTask(expandedTask === t.id ? null : t.id)}
                    >
                      {expandedTask === t.id ? 'Hide' : 'View'} Result
                    </button>
                  )}
                </td>
              </tr>

              {expandedTask === t.id && (
                <tr className="bg-gray-50 border-t">
                  <td colSpan={4} className="p-3">
                    <div className="border rounded p-3 text-sm font-mono whitespace-pre-wrap">
                      {t.result ? (
                        <>
                          <div className="flex justify-between mb-2">
                            <span className="font-semibold">Result Output</span>
                            <button
                              className="text-blue-600 hover:underline text-xs"
                              onClick={() => setModalTask(t.id)}
                            >
                              Open in Modal
                            </button>
                          </div>
                          {t.status === 'failed' ? <span className="text-red-600">{t.result}</span> : <>{t.result}</>}
                        </>
                      ) : (
                        <span className="italic text-gray-500">No result available.</span>
                      )}
                    </div>
                  </td>
                </tr>
              )}
            </>
          ))}
        </tbody>
      </table>

      {modalTask && (
        <TaskResultModal
          open={!!modalTask}
          onClose={() => setModalTask(null)}
          title={tasks.find((t) => t.id === modalTask)?.title || ''}
          result={tasks.find((t) => t.id === modalTask)?.result}
          status={tasks.find((t) => t.id === modalTask)?.status || ''}
        />
      )}
    </div>
  )
}
```

---

## ðŸ§  Step 3 â€” Optional polish: auto-scroll to expanded result

Add this snippet just inside the `TaskList` component (after `useState`):

```tsx
import { useEffect, useRef } from 'react'
const scrollRef = useRef<HTMLTableRowElement | null>(null)
useEffect(() => {
  if (expandedTask && scrollRef.current) {
    scrollRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' })
  }
}, [expandedTask])
```

Then attach `ref={expandedTask === t.id ? scrollRef : null}` to the inline `<tr>` showing the result.

---

## âœ… Final Result Summary

| Feature               | Implementation                    |
| :-------------------- | :-------------------------------- |
| Create new task       | âœ… `TaskForm`                     |
| Run task (LLM chain)  | âœ… `runExistingTask()`            |
| Delete task           | âœ… `deleteExistingTask()`         |
| Auto-polling          | âœ… 5-second interval              |
| Inline result view    | âœ… Expandable section             |
| Modal for full result | âœ… `TaskResultModal`              |
| Status feedback       | âœ… Color badges                   |
| UX polish             | âœ… Smooth scroll + keyboard close |

---

## ðŸ Stage 6.2.5 â€” Complete âœ…

**Outcome achieved:**

> A fully interactive **Task Management UI** that lets users create, run, monitor, and view results of LLM-based async tasks â€” with visual state feedback and inline/modal result viewing.
