## âš™ï¸ **6.3.1 â€“ Tool Framework Setup**

### ğŸ¯ **Goal**

Create a clean, extensible **Tool Framework** that allows adding/removing tools (e.g., calculator, weather, summarizer) easily, with a consistent interface for the agent to invoke them.

---

### ğŸ§© **Concept Overview**

Tools in LangChain (and agent systems generally) are **functions with metadata**.
Each tool has:

- a **name**
- a **description**
- an **execution method** (sync or async)
- optionally an **input schema** for structured input.

Example idea:

```ts
{
  name: 'calculator',
  description: 'Performs arithmetic operations on numbers',
  execute: async (input: string) => string
}
```

You can then dynamically pass these tools into LangChainâ€™s `initializeAgentExecutorWithOptions()` later.

---

### ğŸ—‚ï¸ **Folder Structure**

We'll create a dedicated structure like this:

```
/src/
  /tools/
    baseTool.ts
    calculatorTool.ts
    weatherTool.ts
    summarizerTool.ts
    index.ts
```

---

### ğŸ§  **Step 1: Define a Base Tool Interface**

```ts
// src/tools/baseTool.ts
export interface BaseTool {
  name: string
  description: string
  execute: (input: string) => Promise<string>
}
```

---

### ğŸ§® **Step 2: Implement a Sample Tool â€“ Calculator**

```ts
// src/tools/calculatorTool.ts
import { BaseTool } from './baseTool'

export const calculatorTool: BaseTool = {
  name: 'calculator',
  description: 'Evaluates basic mathematical expressions. Input must be a string like "2 + 2 * 3".',
  async execute(input) {
    try {
      // âš ï¸ simple and safe eval
      const result = Function(`"use strict"; return (${input})`)()
      return `Result: ${result}`
    } catch (err: any) {
      return `Error evaluating expression: ${err.message}`
    }
  },
}
```

---

### ğŸŒ¦ï¸ **Step 3: Add Another Example Tool â€“ Weather (Mock)**

```ts
// src/tools/weatherTool.ts
import { BaseTool } from './baseTool'

export const weatherTool: BaseTool = {
  name: 'weather',
  description: 'Returns mock weather info for a given city.',
  async execute(city) {
    const mockData = {
      temperature: Math.floor(Math.random() * 10 + 25),
      condition: ['Sunny', 'Rainy', 'Cloudy'][Math.floor(Math.random() * 3)],
    }
    return `The weather in ${city} is ${mockData.condition} with ${mockData.temperature}Â°C.`
  },
}
```

---

### ğŸª„ **Step 4: Create a Tool Registry**

```ts
// src/tools/index.ts
import { calculatorTool } from './calculatorTool'
import { weatherTool } from './weatherTool'
import { BaseTool } from './baseTool'

export const availableTools: BaseTool[] = [calculatorTool, weatherTool]
```

---

### ğŸ§° **Step 5: Add a Generic Tool Runner Utility**

Later, this will be called by the agent or backend API.

```ts
// src/tools/runTool.ts
import { availableTools } from './index'

export async function runTool(name: string, input: string): Promise<string> {
  const tool = availableTools.find((t) => t.name === name)
  if (!tool) return `Tool "${name}" not found.`
  return await tool.execute(input)
}
```

---

### âœ… **Result**

We now have:

- A **standardized tool interface**
- **Two sample tools**
- A **registry** for listing all tools
- A **runner utility** for executing any tool dynamically

---

### ğŸ”œ **Next in 6.3.2 â€“ Integrate Tools with Agent**

Weâ€™ll connect this framework with LangChainâ€™s `initializeAgentExecutorWithOptions`, enabling the LLM to:

- Decide **which tool to call**
- Pass structured **inputs**
- Get back the toolâ€™s **output**
